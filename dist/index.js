!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var o in r)("object"==typeof exports?exports:e)[o]=r[o]}}(this,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{IDBDatabaseConnector:()=>o,IDBDatabaseTableConnector:()=>a});const r=require("uuid");class o{dbKey;layout;db;constructor(e,t){this.dbKey=e,this.layout=t}async open(e){return new Promise(((t,r)=>{const o=indexedDB.open(this.dbKey,this.layout.version);o.onupgradeneeded=t=>{const r=t.target,o=r.result,a=r.transaction;e(function(e,t){return{getTables:()=>Array.from(e.objectStoreNames),hasTable:t=>e.objectStoreNames.contains(t),createTable:t=>{e.createObjectStore(t,{keyPath:"id"})},deleteTable:t=>{e.deleteObjectStore(t)},getIndexes:e=>{const r=t?.objectStore(e);return Array.from(r?.indexNames??[])},hasIndex:(e,r)=>{const o=t?.objectStore(e);return o?.indexNames.contains(r)??!1},createIndex:(e,r)=>{const o=t?.objectStore(e);o?.createIndex(r,r)},deleteIndex:(e,r)=>{const o=t?.objectStore(e);o?.deleteIndex(r)}}}(o,a))},o.onsuccess=()=>{this.db=o.result,t()},o.onerror=e=>{r(e)}}))}close(){this.db?.close()}hasTable(e){if(!this.db)throw new Error("Database not open");return this.db.objectStoreNames.contains(e)??!1}createTable(e){if(!this.db)throw new Error("Database not open");if(this.hasTable(e))throw new Error(`Table ${e} already exists`);this.db.createObjectStore(e,{keyPath:"id"})}getTableConnector(e){if(!this.db)throw new Error("Database not open");if(!this.hasTable(e))throw new Error(`Table ${e} does not exist`);return new a(this.db,e)}}class a{db;tableName;constructor(e,t){this.db=e,this.tableName=t}async get(e){const t=this.db.transaction(this.tableName,"readonly").objectStore(this.tableName);return await n(t.get(e))}async set(e,t){const r=this.db.transaction(this.tableName,"readwrite").objectStore(this.tableName),o={...t,id:e};return await n(r.put(o)),o}async add(e){const t=this.db.transaction(this.tableName,"readwrite").objectStore(this.tableName),o={...e,id:(0,r.v4)()};return await n(t.add(o)),o}async delete(e){const t=this.db.transaction(this.tableName,"readwrite").objectStore(this.tableName);await n(t.delete(e))}async clear(){const e=this.db.transaction(this.tableName,"readwrite").objectStore(this.tableName);await n(e.clear())}async list(e){try{const t=this.db.transaction(this.tableName,"readonly").objectStore(this.tableName);let r=null;const o="asc"===e?.orderBy?.direction?"next":"desc"===e?.orderBy?.direction?"prev":void 0;if(e)if(e.where){const a=this.getIndexFromWhereQuery(t,e),n=this.getKeyRange(e.where);r=a.openCursor(n,o)}else e.orderBy?.key&&(r=this.getIndexFromStore(t,e.orderBy.key).openCursor(null,o));r||(r=t.openCursor());const a=[];for await(const t of s(r,e??{}))a.push(t);return a}catch(e){throw new Error("Invalid query")}}async count(e){const t=this.db.transaction(this.tableName,"readonly").objectStore(this.tableName);if(!e?.where)return await n(t.count());const r=this.getIndexFromWhereQuery(t,e),o=this.getKeyRange(e.where);if("!="!==e.where.operator&&"in"!==e.where.operator&&"not-in"!==e.where.operator)return await n(r.count(o));const a=await this.getComplementaryCount(r,e.where);return"in"===e.where.operator?a:await n(t.count())-a}async calculateSize(){const e=this.db.transaction(this.tableName,"readonly").objectStore(this.tableName).openCursor();let t=0;for await(const r of s(e,{}))t+=new Blob([JSON.stringify(r)]).size;return t}getKeyRange(e){if(!e?.operator||!e?.value)throw new Error("Invalid query: where clause must have an operator and a value");const{operator:t,value:r}=e;switch(t){case"==":return IDBKeyRange.only(r);case">":case">=":return IDBKeyRange.lowerBound(r,">"===t);case"<":case"<=":return IDBKeyRange.upperBound(r,"<"===t);case"between":return IDBKeyRange.bound(r[0],r[1]);case"!=":case"not-in":case"in":return;default:throw new Error(`Invalid query: invalid operator: ${t}`)}}getIndexFromWhereQuery(e,t){if(!t.where?.key)throw new Error("Invalid query: where clause must have a key");return e.keyPath===t.where.key?e:this.getIndexFromStore(e,t.where.key)}getIndexFromStore(e,t){try{return e.index(t)}catch(e){throw new Error("Index not found")}}async getComplementaryCount(e,t){const r={...t},o=Array.isArray(t.value)?t.value:[t.value];r.operator="==";let a=0;for(const t of o){r.value=t;const o=this.getKeyRange(r);a+=await n(e.count(o))}return a}}function n(e){return new Promise(((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>r(e.error)}))}async function*s(e,{limit:t=0,offset:r=0,where:o}){let a=0;const{operator:s,key:i,value:c}=o??{};if(r>0){if(await n(e),!e.result)return;e.result.advance(r)}for(;;){await n(e);const{result:r}=e;if(!r)break;if(t>0&&a>=t)break;i&&c&&("!="===s&&c===r.value[i]||"not-in"===s&&c.includes(r.value[i])||"in"===s&&!c.includes(r.value[i]))||(a+=1,yield r.value),r.continue()}}return t})()));